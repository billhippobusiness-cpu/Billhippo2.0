rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ── Helper ─────────────────────────────────────────────────────────────────
    // Returns true when the requesting user is a professional whose linkedClients
    // array contains the given businessUid (the Firestore UID of a business user).
    // Professional profiles are stored at users/{uid}/professional/main.
    function isActiveLinkedProfessional(businessUid) {
      return request.auth != null
        && exists(/databases/$(database)/documents/users/$(request.auth.uid)/professional/main)
        && get(/databases/$(database)/documents/users/$(request.auth.uid)/professional/main)
             .data.linkedClients.hasAny([businessUid]);
    }

    // ── Business portal ────────────────────────────────────────────────────────
    // Business owner has full read/write over their entire user subtree.
    // More-specific rules below ADD professional read access on top of this.
    match /users/{userId}/{document=**} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Allow any authenticated user to remove only their own UID from a
    // professional's linkedClients (needed for the revoke-access flow).
    match /users/{proUid}/professional/main {
      allow update: if request.auth != null
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['linkedClients'])
        && resource.data.linkedClients.hasAll([request.auth.uid])
        && !request.resource.data.linkedClients.hasAny([request.auth.uid]);
    }

    // Top-level users/{businessUid} doc: linked professionals can also read
    // (needed to display business name in the professional portal client list).
    match /users/{businessUid} {
      allow read: if isActiveLinkedProfessional(businessUid);
    }

    // Invoices: linked professional can read for GST report generation.
    match /users/{businessUid}/invoices/{invoiceId} {
      allow read: if isActiveLinkedProfessional(businessUid);
    }

    // Customers: linked professional can read for client management.
    match /users/{businessUid}/customers/{customerId} {
      allow read: if isActiveLinkedProfessional(businessUid);
    }

    // AssignedProfessionals sub-collection:
    //   – Business owner manages via the wildcard rule above.
    //   – Professional can read their own entry (email match in doc).
    //   – Professional can update status/linkedAt/professionalId when
    //     accepting or declining the invite.
    match /users/{businessUid}/assignedProfessionals/{docId} {
      allow read: if request.auth != null
        && resource.data.email == request.auth.token.email.lower();
      allow update: if request.auth != null
        && resource.data.email == request.auth.token.email.lower()
        && request.resource.data.diff(resource.data).affectedKeys()
             .hasOnly(['status', 'linkedAt', 'professionalId']);
    }

    // ── Professional portal ────────────────────────────────────────────────────
    match /professionals/{proUid} {
      // Own profile: read + create.
      allow read:   if request.auth != null && request.auth.uid == proUid;
      allow create: if request.auth != null && request.auth.uid == proUid;

      // Update: own profile only, cannot touch immutable system fields.
      // linkedClients is allowed (needed for invite accept/decline).
      allow update: if request.auth != null && request.auth.uid == proUid
        && !request.resource.data.diff(resource.data).affectedKeys().hasAny([
             'professionalId', 'referralCode', 'uid'
           ]);

      // Activity log: professional creates and reads their own entries.
      match /activityLog/{logId} {
        allow read, create: if request.auth != null && request.auth.uid == proUid;
      }
    }

    // ── Invites ────────────────────────────────────────────────────────────────
    // Invite token is a secret/unguessable string; knowing it is the auth mechanism.
    match /invites/{token} {
      // Business user creates their own invite.
      allow create: if request.auth != null
        && request.resource.data.businessUserUid == request.auth.uid;

      // Any authenticated user who possesses the token URL can read the invite.
      allow read: if request.auth != null;

      // Professional accepting the invite may only write status, acceptedAt,
      // professionalUid, and professionalId.
      allow update: if request.auth != null
        && request.resource.data.diff(resource.data)
             .affectedKeys().hasOnly(['status', 'acceptedAt', 'professionalUid', 'professionalId', 'declinedAt']);
    }

    // ── Counters ───────────────────────────────────────────────────────────────
    // Used by generateProfessionalId() to allocate sequential IDs atomically
    // without needing collection-wide read access on /professionals/.
    match /counters/{counterId} {
      allow read, write: if request.auth != null;
    }

    // ── Referral Index ─────────────────────────────────────────────────────────
    // Fast lookup of professional referral codes (doc ID = referral code).
    // Any authenticated user can read; only the professional who owns the code can write.
    match /referralIndex/{code} {
      allow read: if request.auth != null;
      allow write: if request.auth != null
        && request.resource.data.uid == request.auth.uid;
    }

    // ── Referrals ──────────────────────────────────────────────────────────────
    // Any authenticated user can submit a referral; users read referrals they sent or received.
    match /referrals/{refId} {
      allow create: if request.auth != null;
      allow read:   if request.auth != null
        && (resource.data.referrerId  == request.auth.uid
         || resource.data.referredUid == request.auth.uid);
    }

  }
}
